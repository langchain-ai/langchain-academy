# Chain

## Review
ノード、通常のエッジ、条件付きエッジを持つシンプルなグラフを構築しました。

## Goals
ここでは、4つのコンセプトを組み合わせたシンプルなチェーンを構築していきます:

* グラフの状態として[chat messages]を使用
* グラフのノードで[chat models]を使用
* チャットモデルに[tools]をバインド
* グラフのノードで[function/tool calling]を実行

## Messages
チャットモデルは`messages`を使用でき、これは会話内の異なる役割を表現します。

LangChainは以下のメッセージタイプをサポートしています:
- `HumanMessage` - ユーザーからのメッセージ
- `AIMessage` - チャットモデルからのメッセージ
- `SystemMessage` - チャットモデルの動作を指示するメッセージ
- `ToolMessage` - ツール呼び出しからのメッセージ

メッセージリストを作成してみましょう。

各メッセージには以下の要素を含めることができます:
- `content` - メッセージの内容
- `name` - オプションでメッセージの作成者
- `response_metadata` - オプションでメタデータの辞書(例: `AIMessage`用にモデルプロバイダーによって設定される)

## Chat Models
チャットモデルは、上記で説明したメッセージタイプをサポートし、メッセージのシーケンスを入力として使用できます。

選択肢は多くありますが、ここではOpenAIを使用します。

まずは`OPENAI_API_KEY`が設定されているか確認し、設定されていない場合は入力を求められます。

## Tools
ツールは、モデルが外部システムと対話する必要がある場合に便利です。

外部システム(例:API)は、自然言語ではなく特定の入力スキーマやペイロードを必要とすることがよくあります。

APIをツールとしてバインドする場合、モデルに必要な入力スキーマを認識させることができます。

モデルは、ユーザーからの自然言語入力に基づいてツールを呼び出すことを選択します。

そして、ツールのスキーマに従った出力を返します。

多くのLLMプロバイダーがツール呼び出しをサポートしており、LangChainでのツール呼び出しインターフェースはシンプルです。

Pythonの`function`を`ChatModel.bind_tools(function)`に渡すだけです。

## Using messages as state
グラフの状態で`messages`を使用できます。

状態の`MessagesState`を`TypedDict`として定義し、単一のキー: `messages`を持たせます。

`messages`は、上で定義したメッセージ(例: `HumanMessage`など)のリストです。

## Reducers
ここで小さな問題があります！

各ノードは状態キー`messages`の新しい値を返しますが、この新しい値は以前の`messages`値を上書きしてしまいます。

グラフの実行時に、`messages`状態キーにメッセージを追加したいと考えています。

これにはreducer関数を使用して対処できます。

reducerを使用すると、状態の更新方法を指定できます。

reducer関数が指定されていない場合、更新は以前の値を上書きすると想定されます。

メッセージを追加するには、事前に用意された`add_messages`reducerを使用できます。

これにより、メッセージが既存のメッセージリストに追加されることが保証されます。

`MessagesState`はLangGraphに事前に組み込まれています！

`MessagesState`は以下のように定義されています:
* 事前に組み込まれた単一の`messages`キーを持つ
* これは`AnyMessage`オブジェクトのリスト
* `add_messages`reducerを使用

通常は`MessagesState`を使用します。上記のようにカスタムの`TypedDict`を定義するよりも簡潔だからです。